local TS = game:GetService("TweenService")
local PFS = game:GetService("PathfindingService")

local module = {}

local function getPos(obj)
	return obj.Position or obj.PrimaryPart and obj.PrimaryPart.Position
end

local function move(obj, cf)
	if obj:IsA("BasePart") then
		return {CFrame = cf}
	elseif obj:IsA("Model") then
		return {CFrame = cf}
	end
	return {}
end

local function calcTime(dist, minSp, maxSp)
	if minSp and maxSp then
		local sp = math.clamp(dist, minSp, maxSp)
		return dist / sp
	elseif minSp then
		local sp = math.max(dist, minSp)
		return dist / sp
	elseif maxSp then
		local sp = math.min(dist, maxSp)
		return dist / sp
	else
		return dist / 20
	end
end

function module.CTween(obj, destino, speedMin, speedMax, usePath)
	local originPos = getPos(obj)
	local destPos = destino.Position or destino

	if not originPos then
		error("CTween: objeto inv√°lido")
	end

	local target = typeof(destino) == "CFrame" and destino.Position or destino

	if not usePath then
		local dist = (originPos - target).Magnitude
		local t = calcTime(dist, speedMin, speedMax)
		local info = TweenInfo.new(t, Enum.EasingStyle.Linear)
		local goal = move(obj, CFrame.new(target))
		return TS:Create(obj, info, goal)
	end

	local path = PFS:CreatePath()
	path:ComputeAsync(originPos, target)
	local points = path:GetWaypoints()
	if #points < 2 then
		local dist = (originPos - target).Magnitude
		local t = calcTime(dist, speedMin, speedMax)
		local info = TweenInfo.new(t, Enum.EasingStyle.Linear)
		local goal = move(obj, CFrame.new(target))
		return TS:Create(obj, info, goal)
	end

	local totalDist = 0
	for i = 1, #points - 1 do
		totalDist += (points[i + 1].Position - points[i].Position).Magnitude
	end

	local time = calcTime(totalDist, speedMin, speedMax)
	local goal = move(obj, CFrame.new(points[#points].Position))
	local info = TweenInfo.new(time, Enum.EasingStyle.Linear)
	return TS:Create(obj, info, goal)
end

return module
